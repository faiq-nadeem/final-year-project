{"ast":null,"code":"/*!\r\n * @class GstLaunch\r\n * @brief Class that encapsulates \"gst-launch\" executable.\r\n */\nfunction GstLaunch() {\n  const gst_launch_executable = 'gst-launch-1.0';\n  const gst_launch_versionarg = '--version';\n\n  const SpawnSync = require('child_process').spawnSync;\n\n  const Spawn = require('child_process').spawn;\n\n  const Assert = require('assert');\n\n  const Path = require('path');\n\n  const OS = require('os');\n\n  const FS = require('fs');\n  /*!\r\n   * @fn getPath\r\n   * @brief Returns path to gst-launch or undefined on error\r\n   */\n\n\n  var getPath = function () {\n    var detected_path = undefined;\n\n    if (OS.platform() == 'win32') {\n      // On Windows, GStreamer MSI installer defines the following\n      // environment variables.\n      const detected_path_x64 = process.env.GSTREAMER_1_0_ROOT_X86_64;\n      const detected_path_x32 = process.env.GSTREAMER_1_0_ROOT_X86;\n\n      if (detected_path_x64 || detected_path_x32) {\n        // If both variables are present, favor the architecture\n        // of GStreamer which is the same as Node.js runtime.\n        if (detected_path_x64 && detected_path_x32) {\n          if (process.arch == 'x64') detected_path = detected_path_x64;else if (process.arch == 'x32') detected_path = detected_path_x32;\n        } else {\n          detected_path = detected_path_x64 || detected_path_x32;\n        }\n      }\n\n      if (detected_path) {\n        detected_path = Path.join(detected_path, 'bin', gst_launch_executable + '.exe');\n\n        try {\n          FS.accessSync(detected_path, FS.F_OK);\n        } catch (e) {\n          detected_path = undefined;\n        }\n      } else {\n        // Look for GStreamer on PATH\n        var path_dirs = process.env.PATH.split(';');\n\n        for (var index = 0; index < path_dirs.length; ++index) {\n          try {\n            var base = Path.normalize(path_dirs[index]);\n            var bin = Path.join(base, gst_launch_executable + '.exe');\n            FS.accessSync(bin, FS.F_OK);\n            detected_path = bin;\n          } catch (e) {\n            /* no-op */\n          }\n        }\n      }\n    } else if (OS.platform() == 'linux') {\n      // Look for GStreamer on PATH\n      var path_dirs = process.env.PATH.split(':');\n\n      for (var index = 0; index < path_dirs.length; ++index) {\n        try {\n          var base = Path.normalize(path_dirs[index]);\n          var bin = Path.join(base, gst_launch_executable);\n          FS.accessSync(bin, FS.F_OK);\n          detected_path = bin;\n        } catch (e) {\n          /* no-op */\n        }\n      }\n    }\n\n    return detected_path;\n  };\n  /*!\r\n   * @fn getVersion\r\n   * @brief Returns version string of GStreamer on this machine by\r\n   * invoking the gst-launch executable or 'undefined' on failure.\r\n   */\n\n\n  var getVersion = function () {\n    var version_str = undefined;\n\n    try {\n      var gst_launch_path = getPath();\n      Assert.ok(typeof gst_launch_path, 'string');\n      var output = SpawnSync(gst_launch_path, [gst_launch_versionarg], {\n        'timeout': 1000\n      }).stdout;\n\n      if (output && output.toString().includes('GStreamer')) {\n        version_str = output.toString().match(/GStreamer\\s+.+/g)[0].replace(/GStreamer\\s+/, '');\n      }\n    } catch (ex) {\n      version_str = undefined;\n    }\n\n    return version_str;\n  };\n  /*!\r\n   * @fn isAvailable\r\n   * @brief Answers true if gst-launch executable is available\r\n   */\n\n\n  var isAvailable = function () {\n    return getVersion() != undefined;\n  };\n  /*!\r\n   * @fn spawnPipeline\r\n   * @brief Spawns a GStreamer pipeline using gst-launch\r\n   * @return A Node <child-process> of the launched pipeline\r\n   * @see To construct a correct pipeline arg, consult the link below:\r\n   * https://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-programs.html\r\n   * @usage spawnPipeline('videotestsrc ! autovideosink')\r\n   */\n\n\n  var spawnPipeline = function (pipeline) {\n    Assert.ok(typeof pipeline, 'string');\n    Assert.ok(isAvailable(), \"gst-launch is not available.\");\n    var gst_launch_path = getPath();\n    Assert.ok(typeof gst_launch_path, 'string');\n    return Spawn(gst_launch_path, pipeline.split(' '));\n  };\n\n  return {\n    'getPath': getPath,\n    'getVersion': getVersion,\n    'isAvailable': isAvailable,\n    'spawnPipeline': spawnPipeline\n  };\n}\n/*!\r\n * @class GstLiveCamServer\r\n * @brief Encapsulates a GStreamer pipeline to broadcast default webcam.\r\n */\n\n\nfunction GstLiveCamServer(config) {\n  const Assert = require('assert');\n\n  const OS = require('os');\n\n  Assert.ok(OS.platform() == 'win32' || OS.platform() == 'linux', \"livecam module supports Windows and Linux for broadcasting.\");\n  config = config || {};\n  Assert.ok(typeof config, 'object');\n  const fake = config.fake || false;\n  const width = config.width || 0;\n  const height = config.height || 0;\n  const framerate = config.framerate || 0;\n  const grayscale = config.grayscale || false;\n  Assert.ok(typeof fake, 'boolean');\n  Assert.ok(typeof width, 'number');\n  Assert.ok(typeof height, 'number');\n  Assert.ok(typeof framerate, 'number');\n  Assert.ok(typeof grayscale, 'boolean');\n  var gst_multipart_boundary = '--videoboundary';\n  var gst_video_src = '';\n\n  if (!fake) {\n    if (OS.platform() == 'win32') gst_video_src = 'ksvideosrc ! decodebin';else if (OS.platform() == 'linux') gst_video_src = 'v4l2src ! decodebin';else gst_video_src = 'videotestsrc';\n  } else {\n    gst_video_src = 'videotestsrc';\n  }\n\n  if (width > 0 || height > 0) {\n    gst_video_src += ' ! videoscale ! video/x-raw,width=' + parseInt(width) + ',height=' + parseInt(height);\n  }\n\n  if (framerate > 0) {\n    gst_video_src += ' ! videorate ! video/x-raw,framerate=' + parseInt(framerate) + '/1';\n  }\n\n  if (grayscale) {\n    gst_video_src += ' ! videobalance saturation=0.0 ! videoconvert';\n  }\n  /*!\r\n   * @fn start\r\n   * @brief Starts a GStreamer pipeline that broadcasts the default\r\n   * webcam over the given TCP address and port.\r\n   * @return A Node <child-process> of the launched pipeline\r\n   */\n\n\n  var start = function (tcp_addr, tcp_port) {\n    Assert.ok(typeof tcp_addr, 'string');\n    Assert.ok(typeof tcp_port, 'number');\n    const cam_pipeline = gst_video_src + ' ! jpegenc ! multipartmux  boundary=\"' + gst_multipart_boundary + '\" ! tcpserversink host=' + tcp_addr + ' port=' + tcp_port;\n    var gst_launch = new GstLaunch();\n\n    if (gst_launch.isAvailable()) {\n      console.log('GstLaunch found: ' + gst_launch.getPath());\n      console.log('GStreamer version: ' + gst_launch.getVersion());\n      console.log('GStreamer pipeline: ' + cam_pipeline);\n      return gst_launch.spawnPipeline(cam_pipeline);\n    } else {\n      throw new Error('GstLaunch not found.');\n    }\n  };\n\n  return {\n    'start': start\n  };\n}\n/*!\r\n * @class SocketCamWrapper\r\n * @brief A wrapper that re-broadcasts GStreamer's webcam TCP packets in\r\n * Socket.IO events. This way browsers can fetch and understand webcam\r\n * video frames.\r\n * @credit http://stackoverflow.com/a/23605892/388751\r\n */\n\n\nfunction SocketCamWrapper(gst_tcp_addr, gst_tcp_port, broadcast_tcp_addr, broadcast_tcp_port) {\n  const Net = require('net');\n\n  const Http = require('http');\n\n  const Dicer = require('dicer');\n\n  const Assert = require('assert');\n\n  const SocketIO = require('socket.io');\n\n  const gst_multipart_boundary = '--videoboundary';\n  /*!\r\n   * @fn wrap\r\n   * @brief wraps a TCP server previously started by GstLiveCamServer.\r\n   */\n\n  var wrap = function (gst_tcp_addr, gst_tcp_port, broadcast_tcp_addr, broadcast_tcp_port) {\n    Assert.ok(typeof gst_tcp_addr, 'string');\n    Assert.ok(typeof gst_tcp_port, 'number');\n    Assert.ok(typeof broadcast_tcp_addr, 'string');\n    Assert.ok(typeof broadcast_tcp_port, 'number');\n    var socket = Net.Socket();\n    socket.connect(gst_tcp_port, gst_tcp_addr, function () {\n      var io = SocketIO.listen(Http.createServer().listen(broadcast_tcp_port, broadcast_tcp_addr));\n      var dicer = new Dicer({\n        boundary: gst_multipart_boundary\n      });\n      dicer.on('part', function (part) {\n        var frameEncoded = '';\n        part.setEncoding('base64');\n        part.on('data', function (data) {\n          frameEncoded += data;\n        });\n        part.on('end', function () {\n          io.sockets.emit('image', frameEncoded);\n        });\n      });\n      dicer.on('finish', function () {\n        console.log('Dicer finished: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port);\n      });\n      socket.on('close', function () {\n        console.log('Socket closed: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port);\n      });\n      socket.pipe(dicer);\n    });\n  };\n\n  return {\n    'wrap': wrap\n  };\n}\n/*!\r\n * @class LiveCamUI\r\n * @brief serves a minimal UI to view the webcam broadcast.\r\n */\n\n\nfunction LiveCamUI() {\n  const Http = require('http');\n\n  const Assert = require('assert');\n\n  const template = function () {\n    /*\r\n    <!doctype html>\r\n    <html lang=\"en\">\r\n    <head>\r\n    <meta charset=\"utf-8\">\r\n    <title>livecam UI</title>\r\n    <script type=\"text/javascript\" src=\"https://cdn.socket.io/socket.io-1.4.5.js\"></script>\r\n    <script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.min.js\"></script>\r\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css\">\r\n    <style type=\"text/css\">html,body,.feed,.feed img{width:100%;height:100%;overflow:hidden;}</style>\r\n    </head>\r\n    <body>\r\n    <div class=\"feed\"><img id=\"video\" src=\"\" /></div>\r\n    <script>\r\n    var webcam_addr = \"@WEBCAM_ADDR@\";\r\n    var webcam_port = \"@WEBCAM_PORT@\";\r\n    var webcam_host = $(\".feed img\");\r\n    var socket = io.connect('http://' + webcam_addr + ':' + webcam_port);\r\n    socket.on('image', function (data) {\r\n    webcam_host.attr(\"src\", \"data:image/jpeg;base64,\" + data );\r\n    });\r\n    </script>\r\n    </body>\r\n    </html>\r\n    */\n  }.toString().match(/\\/\\*\\s*([\\s\\S]*?)\\s*\\*\\//m)[1];\n\n  var server = undefined;\n\n  var serve = function (ui_addr, ui_port, webcam_addr, webcam_port) {\n    Assert.ok(typeof ui_addr, 'object');\n    Assert.ok(typeof ui_port, 'number');\n    Assert.ok(typeof webcam_addr, 'object');\n    Assert.ok(typeof webcam_port, 'number');\n    close();\n    server = Http.createServer(function (request, response) {\n      response.writeHead(200, {\n        \"Content-Type\": \"text/html\"\n      });\n      response.write(template.replace('@WEBCAM_ADDR@', webcam_addr).replace('@WEBCAM_PORT@', webcam_port));\n      response.end();\n    });\n    server.listen(ui_port, ui_addr);\n    console.log('Open http://' + ui_addr + ':' + ui_port + '/ in your browser!');\n  };\n\n  var close = function () {\n    if (server) {\n      server.close();\n      server = undefined;\n    }\n  };\n\n  return {\n    'serve': serve,\n    'close': close\n  };\n}\n/*!\r\n * @class LiveCam\r\n * @brief starts a livecam server at given config params\r\n * @note config can have the following options:\r\n * config.gst_tcp_addr --> where GStreamer TCP socket host is\r\n *    [optional] [default: 127.0.0.1]\r\n * config.gst_tcp_port --> where GStreamer TCP socket port is\r\n *    [optional] [default: 10000]\r\n * config.ui_addr --> where minimal UI host is\r\n *    [optional] [default: 127.0.0.1]\r\n * config.ui_port --> where minimal UI port is\r\n *    [optional] [default: 11000]\r\n * config.broadcast_addr --> where Socket IO host is (browser-visible)\r\n *    [optional] [default: 127.0.0.1]\r\n * config.broadcast_port --> where Socket IO port is (browser-visible)\r\n *    [optional] [default: 12000]\r\n * config.start --> event emitted when streaming is started\r\n *    [optional] [default: null]\r\n */\n\n\nfunction LiveCam(config) {\n  const Assert = require('assert');\n\n  config = config || {};\n  Assert.ok(typeof config, 'object');\n  const gst_tcp_addr = config.gst_addr || \"127.0.0.1\";\n  const gst_tcp_port = config.gst_port || 10000;\n  const ui_addr = config.ui_addr || \"127.0.0.1\";\n  const ui_port = config.ui_port || 11000;\n  const broadcast_addr = config.broadcast_addr || \"127.0.0.1\";\n  const broadcast_port = config.broadcast_port || 12000;\n  const start = config.start;\n  const webcam = config.webcam || {};\n  if (start) Assert.ok(typeof start, 'function');\n  if (broadcast_port) Assert.ok(typeof broadcast_port, 'number');\n  if (broadcast_addr) Assert.ok(typeof broadcast_addr, 'string');\n  if (ui_port) Assert.ok(typeof ui_port, 'number');\n  if (ui_addr) Assert.ok(typeof ui_addr, 'string');\n  if (gst_tcp_port) Assert.ok(typeof gst_tcp_port, 'number');\n  if (gst_tcp_addr) Assert.ok(typeof gst_tcp_addr, 'string');\n  if (webcam) Assert.ok(typeof webcam, 'object');\n\n  if (!new GstLaunch().isAvailable()) {\n    console.log(\"==================================================\");\n    console.log(\"Unable to locate gst-launch executable.\");\n    console.log(\"Look at https://github.com/sepehr-laal/livecam\");\n    console.log(\"You are most likely missing the GStreamer runtime.\");\n    console.log(\"==================================================\");\n    throw new Error('Unable to broadcast.');\n  }\n\n  console.log(\"LiveCam parameters:\", {\n    'broadcast_addr': broadcast_addr,\n    'broadcast_port': broadcast_port,\n    'ui_addr': ui_addr,\n    'ui_port': ui_port,\n    'gst_tcp_addr': gst_tcp_addr,\n    'gst_tcp_port': gst_tcp_port\n  });\n\n  var broadcast = function () {\n    var gst_cam_ui = new LiveCamUI();\n    var gst_cam_wrap = new SocketCamWrapper();\n    var gst_cam_server = new GstLiveCamServer(webcam);\n    var gst_cam_process = gst_cam_server.start(gst_tcp_addr, gst_tcp_port);\n    gst_cam_process.stdout.on('data', function (data) {\n      console.log(data.toString()); // This catches GStreamer when pipeline goes into PLAYING state\n\n      if (data.toString().includes('Setting pipeline to PLAYING') > 0) {\n        gst_cam_wrap.wrap(gst_tcp_addr, gst_tcp_port, broadcast_addr, broadcast_port);\n        gst_cam_ui.serve(ui_addr, ui_port, broadcast_addr, broadcast_port);\n        gst_cam_ui.close();\n        if (start) start();\n      }\n    });\n    gst_cam_process.stderr.on('data', function (data) {\n      console.log(data.toString());\n      gst_cam_ui.close();\n    });\n    gst_cam_process.on('error', function (err) {\n      console.log(\"Webcam server error: \" + err);\n      gst_cam_ui.close();\n    });\n    gst_cam_process.on('exit', function (code) {\n      console.log(\"Webcam server exited: \" + code);\n      gst_cam_ui.close();\n    });\n  };\n\n  return {\n    'broadcast': broadcast\n  };\n}\n\nmodule.exports = LiveCam;","map":{"version":3,"sources":["C:/xampp/htdocs/aaa/admin/node_modules/livecam/livecam.js"],"names":["GstLaunch","gst_launch_executable","gst_launch_versionarg","SpawnSync","require","spawnSync","Spawn","spawn","Assert","Path","OS","FS","getPath","detected_path","undefined","platform","detected_path_x64","process","env","GSTREAMER_1_0_ROOT_X86_64","detected_path_x32","GSTREAMER_1_0_ROOT_X86","arch","join","accessSync","F_OK","e","path_dirs","PATH","split","index","length","base","normalize","bin","getVersion","version_str","gst_launch_path","ok","output","stdout","toString","includes","match","replace","ex","isAvailable","spawnPipeline","pipeline","GstLiveCamServer","config","fake","width","height","framerate","grayscale","gst_multipart_boundary","gst_video_src","parseInt","start","tcp_addr","tcp_port","cam_pipeline","gst_launch","console","log","Error","SocketCamWrapper","gst_tcp_addr","gst_tcp_port","broadcast_tcp_addr","broadcast_tcp_port","Net","Http","Dicer","SocketIO","wrap","socket","Socket","connect","io","listen","createServer","dicer","boundary","on","part","frameEncoded","setEncoding","data","sockets","emit","pipe","LiveCamUI","template","server","serve","ui_addr","ui_port","webcam_addr","webcam_port","close","request","response","writeHead","write","end","LiveCam","gst_addr","gst_port","broadcast_addr","broadcast_port","webcam","broadcast","gst_cam_ui","gst_cam_wrap","gst_cam_server","gst_cam_process","stderr","err","code","module","exports"],"mappings":"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","sourcesContent":["/*!\r\n * @class GstLaunch\r\n * @brief Class that encapsulates \"gst-launch\" executable.\r\n */\r\nfunction GstLaunch() {\r\n\t\r\n\tconst gst_launch_executable = 'gst-launch-1.0';\r\n\tconst gst_launch_versionarg = '--version';\r\n\t\r\n\tconst SpawnSync = require('child_process').spawnSync;\r\n\tconst Spawn = require('child_process').spawn;\r\n\tconst Assert = require('assert');\r\n\tconst Path = require('path');\r\n\tconst OS = require('os');\r\n\tconst FS = require('fs');\r\n\t\r\n\t/*!\r\n\t * @fn getPath\r\n\t * @brief Returns path to gst-launch or undefined on error\r\n\t */\r\n\tvar getPath = function() {\r\n\t\tvar detected_path = undefined;\r\n\t\t\r\n\t\tif (OS.platform() == 'win32') {\r\n\t\t\t// On Windows, GStreamer MSI installer defines the following\r\n\t\t\t// environment variables.\r\n\t\t\tconst detected_path_x64 = process.env.GSTREAMER_1_0_ROOT_X86_64;\r\n\t\t\tconst detected_path_x32 = process.env.GSTREAMER_1_0_ROOT_X86;\r\n\t\t\tif (detected_path_x64 || detected_path_x32) {\r\n\t\t\t\t// If both variables are present, favor the architecture\r\n\t\t\t\t// of GStreamer which is the same as Node.js runtime.\r\n\t\t\t\tif (detected_path_x64 && detected_path_x32) {\r\n\t\t\t\t\tif (process.arch == 'x64')\r\n\t\t\t\t\t\tdetected_path = detected_path_x64;\r\n\t\t\t\t\telse if (process.arch == 'x32')\r\n\t\t\t\t\t\tdetected_path = detected_path_x32;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdetected_path = detected_path_x64 || detected_path_x32;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (detected_path) {\r\n\t\t\t\tdetected_path = Path.join(\r\n\t\t\t\t\tdetected_path,\r\n\t\t\t\t\t'bin',\r\n\t\t\t\t\t(gst_launch_executable + '.exe'));\r\n\t\t\t\ttry { FS.accessSync(detected_path, FS.F_OK); }\r\n\t\t\t\tcatch (e) { detected_path = undefined; }\r\n\t\t\t} else {\r\n\t\t\t\t// Look for GStreamer on PATH\r\n\t\t\t\tvar path_dirs = process.env.PATH.split(';');\r\n\t\t\t\tfor (var index = 0; index < path_dirs.length; ++index) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvar base = Path.normalize(path_dirs[index]);\r\n\t\t\t\t\t\tvar bin = Path.join(\r\n\t\t\t\t\t\t\tbase,\r\n\t\t\t\t\t\t\t(gst_launch_executable + '.exe'));\r\n\t\t\t\t\t\tFS.accessSync(bin, FS.F_OK);\r\n\t\t\t\t\t\tdetected_path = bin;\r\n\t\t\t\t\t} catch (e) { /* no-op */ }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (OS.platform() == 'linux') {\r\n\t\t\t// Look for GStreamer on PATH\r\n\t\t\tvar path_dirs = process.env.PATH.split(':');\r\n\t\t\tfor (var index = 0; index < path_dirs.length; ++index) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar base = Path.normalize(path_dirs[index]);\r\n\t\t\t\t\tvar bin = Path.join(\r\n\t\t\t\t\t\tbase,\r\n\t\t\t\t\t\tgst_launch_executable);\r\n\t\t\t\t\tFS.accessSync(bin, FS.F_OK);\r\n\t\t\t\t\tdetected_path = bin;\r\n\t\t\t\t} catch (e) { /* no-op */ }\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn detected_path;\r\n\t}\r\n\t\r\n\t/*!\r\n\t * @fn getVersion\r\n\t * @brief Returns version string of GStreamer on this machine by\r\n\t * invoking the gst-launch executable or 'undefined' on failure.\r\n\t */\r\n\tvar getVersion = function() {\r\n\t\tvar version_str = undefined;\r\n\t\ttry {\r\n\t\t\tvar gst_launch_path = getPath();\r\n\t\t\tAssert.ok(typeof(gst_launch_path), 'string');\r\n\t\t\t\r\n\t\t\tvar output = SpawnSync(\r\n\t\t\t\t\tgst_launch_path,\r\n\t\t\t\t\t[gst_launch_versionarg],\r\n\t\t\t\t\t{ 'timeout' : 1000 })\r\n\t\t\t\t.stdout;\r\n\t\t\t\r\n\t\t\tif (output && output.toString().includes('GStreamer')) {\r\n\t\t\t\tversion_str = output\r\n\t\t\t\t\t.toString()\r\n\t\t\t\t\t.match(/GStreamer\\s+.+/g)[0]\r\n\t\t\t\t\t.replace(/GStreamer\\s+/,'');\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex) {\r\n\t\t\tversion_str = undefined;\r\n\t\t}\r\n\t\t\r\n\t\treturn version_str;\r\n\t}\r\n\t\r\n\t/*!\r\n\t * @fn isAvailable\r\n\t * @brief Answers true if gst-launch executable is available\r\n\t */\r\n\tvar isAvailable = function() {\r\n\t\treturn getVersion() != undefined;\r\n\t}\r\n\t\r\n\t/*!\r\n\t * @fn spawnPipeline\r\n\t * @brief Spawns a GStreamer pipeline using gst-launch\r\n\t * @return A Node <child-process> of the launched pipeline\r\n\t * @see To construct a correct pipeline arg, consult the link below:\r\n\t * https://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-programs.html\r\n\t * @usage spawnPipeline('videotestsrc ! autovideosink')\r\n\t */\r\n\tvar spawnPipeline = function(pipeline) {\r\n\t\tAssert.ok(typeof(pipeline), 'string');\r\n\t\tAssert.ok(isAvailable(), \"gst-launch is not available.\");\r\n\t\t\r\n\t\tvar gst_launch_path = getPath();\r\n\t\tAssert.ok(typeof(gst_launch_path), 'string');\r\n\t\t\t\r\n\t\treturn Spawn(gst_launch_path, pipeline.split(' '));\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t'getPath' : getPath,\r\n\t\t'getVersion' : getVersion,\r\n\t\t'isAvailable' : isAvailable,\r\n\t\t'spawnPipeline' : spawnPipeline\r\n\t}\r\n\t\r\n}\r\n\r\n/*!\r\n * @class GstLiveCamServer\r\n * @brief Encapsulates a GStreamer pipeline to broadcast default webcam.\r\n */\r\nfunction GstLiveCamServer(config) {\r\n\t\r\n\tconst Assert = require('assert');\r\n\tconst OS = require('os');\r\n\t\r\n\tAssert.ok(OS.platform() == 'win32' || OS.platform() == 'linux',\r\n\t\"livecam module supports Windows and Linux for broadcasting.\");\r\n\t\r\n\tconfig = config || {};\r\n\tAssert.ok(typeof(config), 'object');\r\n\t\r\n\tconst fake = config.fake || false;\r\n\tconst width = config.width || 0;\r\n\tconst height = config.height || 0;\r\n\tconst framerate = config.framerate || 0;\r\n\tconst grayscale = config.grayscale || false;\r\n\t\r\n\tAssert.ok(typeof(fake), 'boolean');\r\n\tAssert.ok(typeof(width), 'number');\r\n\tAssert.ok(typeof(height), 'number');\r\n\tAssert.ok(typeof(framerate), 'number');\r\n\tAssert.ok(typeof(grayscale), 'boolean');\r\n\t\r\n\tvar gst_multipart_boundary = '--videoboundary';\r\n\tvar gst_video_src = '';\r\n\t\r\n\tif (!fake) {\r\n\t\tif (OS.platform() == 'win32')\r\n\t\t\tgst_video_src = 'ksvideosrc ! decodebin';\r\n\t\telse if (OS.platform() == 'linux')\r\n\t\t\tgst_video_src = 'v4l2src ! decodebin';\r\n\t\telse\r\n\t\t\tgst_video_src = 'videotestsrc';\r\n\t} else {\r\n\t\tgst_video_src = 'videotestsrc';\r\n\t}\r\n\t\r\n\tif (width > 0 || height > 0) {\r\n\t\tgst_video_src += ' ! videoscale ! video/x-raw,width=' + parseInt(width) + ',height=' + parseInt(height);\r\n\t}\r\n\t\r\n\tif (framerate > 0) {\r\n\t\tgst_video_src += ' ! videorate ! video/x-raw,framerate=' + parseInt(framerate) + '/1';\r\n\t}\r\n\t\r\n\tif (grayscale) {\r\n\t\tgst_video_src += ' ! videobalance saturation=0.0 ! videoconvert';\r\n\t}\r\n\t\r\n\t/*!\r\n\t * @fn start\r\n\t * @brief Starts a GStreamer pipeline that broadcasts the default\r\n\t * webcam over the given TCP address and port.\r\n\t * @return A Node <child-process> of the launched pipeline\r\n\t */\r\n\tvar start = function(tcp_addr, tcp_port) {\r\n\t\tAssert.ok(typeof(tcp_addr), 'string');\r\n\t\tAssert.ok(typeof(tcp_port), 'number');\r\n\t\t\r\n\t\tconst cam_pipeline = gst_video_src + ' ! jpegenc ! multipartmux  boundary=\"'\r\n\t\t+ gst_multipart_boundary + '\" ! tcpserversink host=' + tcp_addr + ' port=' + tcp_port;\r\n\t\t\r\n\t\tvar gst_launch = new GstLaunch();\r\n\t\t\r\n\t\tif (gst_launch.isAvailable()) {\r\n\t\t\tconsole.log('GstLaunch found: ' + gst_launch.getPath());\r\n\t\t\tconsole.log('GStreamer version: ' + gst_launch.getVersion());\r\n\t\t\tconsole.log('GStreamer pipeline: ' + cam_pipeline);\r\n\t\t\t\r\n\t\t\treturn gst_launch.spawnPipeline(cam_pipeline);\r\n\t\t} else {\r\n\t\t\tthrow new Error('GstLaunch not found.');\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t'start' : start\r\n\t}\r\n\t\r\n}\r\n\r\n/*!\r\n * @class SocketCamWrapper\r\n * @brief A wrapper that re-broadcasts GStreamer's webcam TCP packets in\r\n * Socket.IO events. This way browsers can fetch and understand webcam\r\n * video frames.\r\n * @credit http://stackoverflow.com/a/23605892/388751\r\n */\r\nfunction SocketCamWrapper(\r\n\tgst_tcp_addr,\r\n\tgst_tcp_port,\r\n\tbroadcast_tcp_addr,\r\n\tbroadcast_tcp_port) {\r\n\r\n\tconst Net = require('net');\r\n\tconst Http = require('http');\r\n\tconst Dicer = require('dicer');\r\n\tconst Assert = require('assert');\r\n\tconst SocketIO = require('socket.io');\r\n\tconst gst_multipart_boundary = '--videoboundary';\r\n\t\r\n\t/*!\r\n\t * @fn wrap\r\n\t * @brief wraps a TCP server previously started by GstLiveCamServer.\r\n\t */\r\n\tvar wrap = function(gst_tcp_addr,\r\n\t\t\t\t\t\tgst_tcp_port,\r\n\t\t\t\t\t\tbroadcast_tcp_addr,\r\n\t\t\t\t\t\tbroadcast_tcp_port) {\r\n\t\tAssert.ok(typeof(gst_tcp_addr), 'string');\r\n\t\tAssert.ok(typeof(gst_tcp_port), 'number');\r\n\t\tAssert.ok(typeof(broadcast_tcp_addr), 'string');\r\n\t\tAssert.ok(typeof(broadcast_tcp_port), 'number');\r\n\t\t\r\n\t\tvar socket = Net.Socket();\r\n\t\t\r\n\t\tsocket.connect(gst_tcp_port, gst_tcp_addr, function() {\r\n\t\t\tvar io = SocketIO.listen(\r\n\t\t\t\tHttp.createServer()\r\n\t\t\t\t.listen(broadcast_tcp_port, broadcast_tcp_addr));\r\n\t\t\t\r\n\t\t\tvar dicer = new Dicer({ boundary: gst_multipart_boundary });\r\n\r\n\t\t\tdicer.on('part', function(part) {\r\n\t\t\t\tvar frameEncoded = '';\r\n\t\t\t\tpart.setEncoding('base64');\r\n\r\n\t\t\t\tpart.on('data', function(data) { frameEncoded += data; });\r\n\t\t\t\tpart.on('end', function() { io.sockets.emit('image', frameEncoded); });\r\n\t\t\t});\r\n\r\n\t\t\tdicer.on('finish', function() {\r\n\t\t\t\tconsole.log('Dicer finished: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tsocket.on('close', function() {\r\n\t\t\t\tconsole.log('Socket closed: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port);\r\n\t\t\t});\r\n\r\n\t\t\tsocket.pipe(dicer);\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t'wrap' : wrap\r\n\t}\r\n}\r\n\r\n/*!\r\n * @class LiveCamUI\r\n * @brief serves a minimal UI to view the webcam broadcast.\r\n */\r\nfunction LiveCamUI() {\r\n\t\r\n\tconst Http = require('http');\r\n\tconst Assert = require('assert');\r\n\tconst template = (function(){/*\r\n\t<!doctype html>\r\n\t<html lang=\"en\">\r\n\t\t<head>\r\n\t\t\t<meta charset=\"utf-8\">\r\n\t\t\t<title>livecam UI</title>\r\n\t\t\t<script type=\"text/javascript\" src=\"https://cdn.socket.io/socket.io-1.4.5.js\"></script>\r\n\t\t\t<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.min.js\"></script>\r\n\t\t\t<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css\">\r\n\t\t\t<style type=\"text/css\">html,body,.feed,.feed img{width:100%;height:100%;overflow:hidden;}</style>\r\n\t\t</head>\r\n\t\t<body>\r\n\t\t\t<div class=\"feed\"><img id=\"video\" src=\"\" /></div>\r\n\t\t\t<script>\r\n\t\t\t\tvar webcam_addr = \"@WEBCAM_ADDR@\";\r\n\t\t\t\tvar webcam_port = \"@WEBCAM_PORT@\";\r\n\t\t\t\tvar webcam_host = $(\".feed img\");\r\n\t\t\t\tvar socket = io.connect('http://' + webcam_addr + ':' + webcam_port);\r\n\t\t\t\t\r\n\t\t\t\tsocket.on('image', function (data) {\r\n\t\t\t\t\twebcam_host.attr(\"src\", \"data:image/jpeg;base64,\" + data );\r\n\t\t\t\t});\r\n\t\t\t</script>\r\n\t\t</body>\r\n\t</html>\r\n\t*/}).toString().match(/\\/\\*\\s*([\\s\\S]*?)\\s*\\*\\//m)[1];\r\n\t\r\n\tvar server = undefined;\r\n\t\r\n\tvar serve = function(ui_addr, ui_port, webcam_addr, webcam_port) {\r\n\t\tAssert.ok(typeof(ui_addr), 'object');\r\n\t\tAssert.ok(typeof(ui_port), 'number');\r\n\t\tAssert.ok(typeof(webcam_addr), 'object');\r\n\t\tAssert.ok(typeof(webcam_port), 'number');\r\n\t\t\r\n\t\tclose();\r\n\t\tserver = Http.createServer(function(request, response) {\r\n\t\t\tresponse.writeHead(200, {\"Content-Type\": \"text/html\"});\r\n\t\t\tresponse.write(template\r\n\t\t\t\t.replace('@WEBCAM_ADDR@', webcam_addr)\r\n\t\t\t\t.replace('@WEBCAM_PORT@', webcam_port));\r\n\t\t\tresponse.end();\r\n\t\t});\r\n\t\tserver.listen(ui_port, ui_addr);\r\n\t\t\r\n\t\tconsole.log('Open http://' + ui_addr + ':' + ui_port + '/ in your browser!');\r\n\t}\r\n\t\r\n\tvar close = function() {\r\n\t\tif (server) {\r\n\t\t\tserver.close();\r\n\t\t\tserver = undefined;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t'serve' : serve,\r\n\t\t'close' : close\r\n\t}\r\n\t\r\n}\r\n\r\n/*!\r\n * @class LiveCam\r\n * @brief starts a livecam server at given config params\r\n * @note config can have the following options:\r\n * config.gst_tcp_addr --> where GStreamer TCP socket host is\r\n *    [optional] [default: 127.0.0.1]\r\n * config.gst_tcp_port --> where GStreamer TCP socket port is\r\n *    [optional] [default: 10000]\r\n * config.ui_addr --> where minimal UI host is\r\n *    [optional] [default: 127.0.0.1]\r\n * config.ui_port --> where minimal UI port is\r\n *    [optional] [default: 11000]\r\n * config.broadcast_addr --> where Socket IO host is (browser-visible)\r\n *    [optional] [default: 127.0.0.1]\r\n * config.broadcast_port --> where Socket IO port is (browser-visible)\r\n *    [optional] [default: 12000]\r\n * config.start --> event emitted when streaming is started\r\n *    [optional] [default: null]\r\n */\r\nfunction LiveCam(config) {\r\n\t\r\n\tconst Assert = require('assert');\r\n\t\r\n\tconfig = config || {};\r\n\tAssert.ok(typeof(config), 'object');\r\n\t\r\n\tconst gst_tcp_addr = config.gst_addr || \"127.0.0.1\";\r\n\tconst gst_tcp_port = config.gst_port || 10000;\r\n\tconst ui_addr = config.ui_addr || \"127.0.0.1\";\r\n\tconst ui_port = config.ui_port || 11000;\r\n\tconst broadcast_addr = config.broadcast_addr || \"127.0.0.1\";\r\n\tconst broadcast_port = config.broadcast_port || 12000;\r\n\tconst start = config.start;\r\n\tconst webcam = config.webcam || {};\r\n\t\r\n\tif (start) Assert.ok(typeof(start), 'function');\r\n\tif (broadcast_port) Assert.ok(typeof(broadcast_port), 'number');\r\n\tif (broadcast_addr) Assert.ok(typeof(broadcast_addr), 'string');\r\n\tif (ui_port) Assert.ok(typeof(ui_port), 'number');\r\n\tif (ui_addr) Assert.ok(typeof(ui_addr), 'string');\r\n\tif (gst_tcp_port) Assert.ok(typeof(gst_tcp_port), 'number');\r\n\tif (gst_tcp_addr) Assert.ok(typeof(gst_tcp_addr), 'string');\r\n\tif (webcam) Assert.ok(typeof(webcam), 'object');\r\n\t\r\n\tif (!(new GstLaunch()).isAvailable())\r\n\t{\r\n\t\tconsole.log(\"==================================================\");\r\n\t\tconsole.log(\"Unable to locate gst-launch executable.\");\r\n\t\tconsole.log(\"Look at https://github.com/sepehr-laal/livecam\");\r\n\t\tconsole.log(\"You are most likely missing the GStreamer runtime.\");\r\n\t\tconsole.log(\"==================================================\");\r\n\t\t\r\n\t\tthrow new Error('Unable to broadcast.');\r\n\t}\r\n\t\r\n\tconsole.log(\"LiveCam parameters:\", {\r\n\t\t'broadcast_addr' : broadcast_addr,\r\n\t\t'broadcast_port' : broadcast_port,\r\n\t\t'ui_addr' : ui_addr,\r\n\t\t'ui_port' : ui_port,\r\n\t\t'gst_tcp_addr' : gst_tcp_addr,\r\n\t\t'gst_tcp_port' : gst_tcp_port\r\n\t});\r\n\t\r\n\tvar broadcast = function() {\r\n\t\tvar gst_cam_ui = new LiveCamUI();\r\n\t\tvar gst_cam_wrap = new SocketCamWrapper();\r\n\t\tvar gst_cam_server = new GstLiveCamServer(webcam);\r\n\t\tvar gst_cam_process = gst_cam_server.start(gst_tcp_addr, gst_tcp_port);\r\n\t\t\r\n\t\tgst_cam_process.stdout.on('data', function(data) {\r\n\t\t\tconsole.log(data.toString());\r\n\t\t\t// This catches GStreamer when pipeline goes into PLAYING state\r\n\t\t\tif(data.toString().includes('Setting pipeline to PLAYING') > 0) {\r\n\t\t\t\tgst_cam_wrap.wrap(gst_tcp_addr, gst_tcp_port, broadcast_addr, broadcast_port);\r\n\t\t\t\tgst_cam_ui.serve(ui_addr, ui_port, broadcast_addr, broadcast_port);\r\n\t\t\t\tgst_cam_ui.close();\r\n\t\t\t\t\r\n\t\t\t\tif (start) start();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tgst_cam_process.stderr.on('data', function(data) { console.log(data.toString()); gst_cam_ui.close(); });\r\n\t\tgst_cam_process.on('error', function(err) { console.log(\"Webcam server error: \" + err); gst_cam_ui.close(); });\r\n\t\tgst_cam_process.on('exit', function(code) { console.log(\"Webcam server exited: \" + code); gst_cam_ui.close(); });\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t'broadcast' : broadcast\r\n\t}\r\n\t\r\n}\r\n\r\nmodule.exports = LiveCam;\r\n"]},"metadata":{},"sourceType":"script"}